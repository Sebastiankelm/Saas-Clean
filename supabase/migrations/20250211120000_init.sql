set check_function_bodies = off;

create or replace function public.set_updated_at()
returns trigger
language plpgsql
as $$
begin
  new.updated_at = now();
  return new;
end;
$$;

create table if not exists public.users (
  id bigint generated by default as identity primary key,
  name text,
  email text not null unique,
  password_hash text not null,
  role text not null default 'member' check (role in ('owner','admin','member')),
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  deleted_at timestamptz
);

create trigger set_users_updated_at
  before update on public.users
  for each row
  execute procedure public.set_updated_at();

create index if not exists users_email_idx on public.users (email);
create index if not exists users_deleted_at_idx on public.users (deleted_at);

create table if not exists public.teams (
  id bigint generated by default as identity primary key,
  name text not null,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

create trigger set_teams_updated_at
  before update on public.teams
  for each row
  execute procedure public.set_updated_at();

create table if not exists public.team_members (
  id bigint generated by default as identity primary key,
  user_id bigint not null references public.users(id) on delete cascade,
  team_id bigint not null references public.teams(id) on delete cascade,
  role text not null default 'member' check (role in ('owner','admin','member')),
  joined_at timestamptz not null default now(),
  constraint team_members_unique_member unique(team_id, user_id)
);

create index if not exists team_members_user_id_idx on public.team_members (user_id);
create index if not exists team_members_team_id_idx on public.team_members (team_id, role);

create table if not exists public.activity_logs (
  id bigint generated by default as identity primary key,
  team_id bigint not null references public.teams(id) on delete cascade,
  user_id bigint references public.users(id) on delete set null,
  action text not null,
  occurred_at timestamptz not null default now(),
  ip_address text
);

create index if not exists activity_logs_team_id_idx on public.activity_logs (team_id, occurred_at desc);
create index if not exists activity_logs_user_id_idx on public.activity_logs (user_id, occurred_at desc);

create table if not exists public.invitations (
  id bigint generated by default as identity primary key,
  team_id bigint not null references public.teams(id) on delete cascade,
  email text not null,
  role text not null default 'member' check (role in ('owner','admin','member')),
  invited_by bigint not null references public.users(id) on delete cascade,
  invited_at timestamptz not null default now(),
  status text not null default 'pending' check (status in ('pending','accepted','revoked'))
);

create index if not exists invitations_email_idx on public.invitations (lower(email), status);
create index if not exists invitations_team_idx on public.invitations (team_id, status);

create table if not exists public.billing_customers (
  id bigint generated by default as identity primary key,
  team_id bigint not null references public.teams(id) on delete cascade,
  stripe_customer_id text not null unique,
  email text,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

create trigger set_billing_customers_updated_at
  before update on public.billing_customers
  for each row
  execute procedure public.set_updated_at();

create index if not exists billing_customers_team_id_idx on public.billing_customers (team_id);

create table if not exists public.subscriptions (
  id bigint generated by default as identity primary key,
  team_id bigint not null references public.teams(id) on delete cascade,
  stripe_subscription_id text not null unique,
  status text not null,
  stripe_product_id text,
  stripe_price_id text,
  plan_name text,
  current_period_end timestamptz,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

create trigger set_subscriptions_updated_at
  before update on public.subscriptions
  for each row
  execute procedure public.set_updated_at();

create index if not exists subscriptions_team_id_idx on public.subscriptions (team_id, status);
create index if not exists subscriptions_status_idx on public.subscriptions (status);

create materialized view if not exists public.team_memberships_mv as
select
  tm.team_id,
  tm.user_id,
  tm.role,
  t.name as team_name
from public.team_members tm
join public.teams t on t.id = tm.team_id;

create unique index if not exists team_memberships_mv_team_user_idx
  on public.team_memberships_mv (team_id, user_id);

create materialized view if not exists public.team_billing_mv as
select distinct on (t.id)
  t.id as team_id,
  bc.stripe_customer_id,
  s.stripe_subscription_id,
  s.status as subscription_status,
  s.plan_name,
  s.stripe_product_id,
  s.stripe_price_id
from public.teams t
left join public.billing_customers bc on bc.team_id = t.id
left join public.subscriptions s on s.team_id = t.id
order by t.id, s.updated_at desc nulls last;

create unique index if not exists team_billing_mv_team_id_idx
  on public.team_billing_mv (team_id);

create or replace function public.refresh_team_views()
returns void
language plpgsql
security definer
set search_path = public
as $$
begin
  refresh materialized view public.team_memberships_mv;
  refresh materialized view public.team_billing_mv;
end;
$$;

grant execute on function public.refresh_team_views() to authenticated, anon;

create or replace function public.current_app_user_id()
returns bigint
language sql
stable
as $$
  select nullif(current_setting('request.jwt.claims', true)::json->>'app_user_id', '')::bigint;
$$;

create or replace function public.current_app_user_role(p_team_id bigint)
returns text
language plpgsql
stable
security definer
set search_path = public
as $$
declare
  v_role text;
begin
  select tm.role into v_role
  from public.team_members tm
  where tm.team_id = p_team_id
    and tm.user_id = public.current_app_user_id()
  limit 1;
  return v_role;
end;
$$;

alter table public.users enable row level security;
alter table public.teams enable row level security;
alter table public.team_members enable row level security;
alter table public.activity_logs enable row level security;
alter table public.invitations enable row level security;
alter table public.billing_customers enable row level security;
alter table public.subscriptions enable row level security;

create policy users_self_access on public.users
  for select
  using (id = public.current_app_user_id());

create policy users_self_update on public.users
  for update
  using (id = public.current_app_user_id())
  with check (id = public.current_app_user_id());

create policy teams_member_select on public.teams
  for select
  using (exists (
    select 1 from public.team_members tm
    where tm.team_id = teams.id
      and tm.user_id = public.current_app_user_id()
  ));

create policy teams_member_insert on public.teams
  for insert
  with check (public.current_app_user_id() is not null);

create policy teams_owner_update on public.teams
  for update
  using (public.current_app_user_role(id) in ('owner','admin'))
  with check (public.current_app_user_role(id) in ('owner','admin'));

create policy team_members_read on public.team_members
  for select
  using (
    public.current_app_user_role(team_id) is not null
  );

create policy team_members_manage on public.team_members
  for all
  using (public.current_app_user_role(team_id) in ('owner','admin'))
  with check (public.current_app_user_role(team_id) in ('owner','admin'));

create policy activity_logs_read on public.activity_logs
  for select
  using (
    public.current_app_user_role(team_id) is not null or user_id = public.current_app_user_id()
  );

create policy invitations_read on public.invitations
  for select
  using (public.current_app_user_role(team_id) is not null);

create policy invitations_manage on public.invitations
  for all
  using (public.current_app_user_role(team_id) in ('owner','admin'))
  with check (public.current_app_user_role(team_id) in ('owner','admin'));

create policy billing_customers_read on public.billing_customers
  for select
  using (public.current_app_user_role(team_id) in ('owner','admin'));

create policy subscriptions_read on public.subscriptions
  for select
  using (public.current_app_user_role(team_id) in ('owner','admin'));

